@import Main._
@sect{Error Reporting}
    @p
        This section goes into detail of how the FastParse error reporting
        algorithm works. In general, it should "just work" when you call
        @code{.longMsg}, @code{.longAggregateMsg}, or @code{.longTerminalsMsg}.
        Nevertheless, it is both complicated as well important enough that it
        is worth documenting in detail

    @p
        Fastparse provides two levels of error reporting that get enabled when
        calling @code{.trace()}. For the following explanations, consider an example
        failed parse of a simplified arithmetic parser:

    @hl.ref(tests/"ExampleTests.scala", Seq("\"errorHandlingExplanation\"", ""))

    @p
        This fails on the @code{?} being invalid syntax. The following error reporting
        levels will treat this as follows:
    @ul
        @li
          @code{failureTerminals} lists all the lowest-level terminal parsers which are
          tried at the given @code{traceIndex}, i.e. the character class @code{[0-9]} and the
          token "(". This is useful to answer the question "what token/char can I
          put at the error position to make my parse continue". The implementation
          of @code{failureTerminals} is straightforward: we simply call
          @code{reportTerminalMsg} in every terminal parser, which collects all the
          messages in a big list and returns it.
        @li
          @code{failureAggregates} lists all high-level parsers which are tried at the given
          @code{traceIndex}, i.e. the named parsers @code{num} and @code{plus}. This is useful to
          answer the question "What construct was the parser trying to do when it
          failed"
    @p
        The implementation of @code{failureAggregates} is more interesting, since we need
        to define what "high level" parsers means, which is non-obvious. Fastparse
        uses the following definition:
    @ul
        @li
         @code{failureAggregates} should contain the parsers highest in the call stack,
          whose failure isn't immediately fatal to the parse (due to them being in
          @code{|}, @code{.rep}, @code{?}, or other "backtrackable" operators, but
          not past a @code{cut})
    @p
        This is a useful definition because we already have the @code{failureStack}
        containing all (named) parsers whose failure *is* immediately fatal to the
        parse, both those at @code{traceIndex} and those earlier in the input. This
        there is no need to duplicate showing any of them in the @code{failureAggregates},
        and we can instead go "one level deeper" to find the highest-level parsers
        within the deepest parser of the @code{failureStack} and show those instead.
        Thus, in the combined @code{longAggregateMsg}, the failure stack shows us
        exactly which parsers failing directly contributed to the failure at
        @code{traceIndex}, while the longAggregateMsg tells us what are the
        highest-level parsers FastParse was trying to parse at @code{traceIndex} before
        it finally failed.
    @p
        To collect the @code{failureAggregates}, We use the following algorithm:
    @ul
        @li
          When a parse which started at the given @code{traceIndex} fails without a cut:
          Over-write @code{failureAggregates} with it's @code{shortParserMsg}

        @li
            Otherwise:

            @ul
                @li
                    If we are a terminal parser, we set our @code{failureAggregates} to Nil
                @li
                    If we are a compound parser, we simply sum up the @code{failureAggregates}
                    of all our constituent parts
    @p
        The point of this heuristic is to provide the highest-level parsers which
        failed at the @code{traceIndex}, but are not already part of the @code{failureStack}.
        non-highest-level parsers do successfully write their message to
        @code{failureAggregates}, but they are subsequently over-written by the higher
        level parsers, until it reaches the point where @code{cut == true}, indicating
        that any further higher-level parsers will be in @code{failureStack} and using
        their message to stomp over the existing parse-failure-messages in
        @code{failureAggregates} would be wasteful.
    @p
        These is an edge case where there is no given failure that occurs exactly at
        @code{traceIndex} e.g.
    @ul
        @li
            Parsing @hl.scala{"ax"} with @hl.scala{P( ("a" ~ "b") ~ "c" | "a" ~/ "d" )}
        @li
            The final failure @code{index} and thus @code{traceIndex} is at offset 1
        @li
            We would like to receive the aggregation @hl.scala{("b" | "d")}
        @li
            But @hl.scala{("a" ~ "b")} passes from offsets 0-2, @hl.scala{"c"} fails


    @p
        In such a case, we truncate the @code{shortParserMsg} at
        @code{traceIndex} to only include the portion we're interested in (which directly
        follows the failure). This then gets aggregated nicely to form the error
        message from-point-of-failure.
    @p
        A follow-on edge case is parsing "ax" with
    @hl.scala
        val inner = P( "a" ~ "b" )
        P( inner ~ "c" | "a" ~/ "d" )
    @ul
        @li
            Here, we find that the @code{inner} parser starts before the @code{traceIndex} and
            fails at @code{traceIndex},
        @li
            But we want our aggregation to continue being @hl.scala{("b" | "d")}, rather than
            @hl.scala{(inner | "d")}.

        Thus, for opaque compound parsers like @code{inner} which do not expose their
        internals, we use @code{forceAggregate} to force it to expose it's internals
        when it's range covers the @code{traceIndex} but it isn't an exact match
